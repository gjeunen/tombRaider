#! /usr/bin/env python3


##################
# IMPORT MODULES #
##################
import argparse
from tqdm import tqdm
import os
import itertools
from Bio import pairwise2
import collections

from function import __version__
from function.tombRaiderFunctions import freqToMemory, zotuToMemory, taxToMemory, dictionarySum


#########################
# MODULE mrcaCalculator #
#########################
# function to calculate the most recent common ancestor from BLAST
def mrcaCalculator(args):
    INPUT = args.input


#####################
# MODULE mrcaMerger #
#####################
# function to merge sequences based on the most recent common ancestor ID
def mrcaMerger(args):
    INPUT = args.input


######################
# MODULE occurMerger #
######################
# function to merge sequences based on co-occurrence patterns
def occurMerger(args):
    INPUT = args.input


#####################
# MODULE tombRaider #
#####################
# function to merge sequences based on taxon-dependent co-occurrence patterns
def tombRaider(args):
    FREQINPUT = args.freqInput
    SEQINPUT = args.seqInput
    TAXINPUT = args.taxInput
    FREQOUTPUT = args.freqOutput
    SEQOUTPUT = args.seqOutput
    TAXOUTPUT = args.taxOutput
    ABUNDANCE = args.abund
    SIMILARITY = args.similarity

## starting print statement
    print(f'\ntombRaider v{__version__}\nhttps://github.com/gjeunen/tombRaider\n\n')

## read FREQ, ZOTU, and TAX into memory
    try:
       with tqdm(total = os.path.getsize(FREQINPUT) + os.path.getsize(SEQINPUT) + os.path.getsize(TAXINPUT), desc = f'Reading Input Files into memory: ', bar_format = '{desc}{percentage:.1f}%|{bar}|{elapsed}<{remaining}') as pbar:
           freqInputDict, freqTotalCountDict, pbar = freqToMemory(FREQINPUT, pbar)
           seqInputDict, pbar = zotuToMemory(SEQINPUT, pbar)
           taxIdInputDict, taxQcovInputDict, taxPidentInputDict, taxTotalDict, pbar = taxToMemory(TAXINPUT, pbar)
    except TypeError:
       print(f'FATAL ERROR: "--frequency-input" and/or "--sequence-input" and/or "--taxonomy-input" parameter(s) not provided, aborting analysis...\n')
       exit()
    except FileNotFoundError:
       print(f'FATAL ERROR: {FREQINPUT} and/or {SEQINPUT} and/or {TAXINPUT} file(s) not found, aborting analysis...\n')
       exit()

## calculate number of unique combinations for tqdm print (x = ((n*n)-n)/2)
    uniqueCombinations = int(((len(freqTotalCountDict) * len(freqTotalCountDict)) - len(freqTotalCountDict)) / 2)

## determine parent and child sequences
## 1. check accession numbers match
# currently only on top blast hit
    newlyUpdatedCountDict = collections.defaultdict(list)
    combinedDict = collections.defaultdict(list)
    childParentComboDict = {}
    conflictDict = collections.defaultdict(list)
    with tqdm(total = uniqueCombinations, desc = 'Identify artefacts: ', bar_format = '{desc}{percentage:.1f}%|{bar}|{elapsed}<{remaining}') as pbar:
        for parent in range(len(freqTotalCountDict.keys())):
            parentName = list(freqTotalCountDict.keys())[parent]
            newParentDict = freqInputDict[parentName]
            for child in range(parent + 1, len(freqTotalCountDict.keys())):
                pbar.update(1)
                childName = list(freqTotalCountDict.keys())[child]
                try:
                    # 1. check if BLAST tax ID is the same
                    if taxIdInputDict[parentName] != taxIdInputDict[childName]:
                        continue
                    # 2. check BLAST quality on percent identity and query coverage are lower for child than parent
                    if taxPidentInputDict[childName] > taxPidentInputDict[parentName] and taxQcovInputDict[childName] > taxQcovInputDict[parentName]:
                        continue
                    # 3. check if child only appears in samples where parent is present
                    # remove negative controls from co-occurrence patterns
                    # what about abundance?
                    try:
                        positiveDetectionB = [k for k, v in freqInputDict[childName].items() if v >= ABUNDANCE]
                    except TypeError:
                        print(f'FATAL ERROR: "-a", "--abundance" parameter not provided, aborting analysis...\n')
                        exit()
                    positiveDetectionA = [k for k, v in freqInputDict[parentName].items() if v > 0]
                    if not all(item in positiveDetectionA for item in positiveDetectionB):
                        continue
                    # 4. check sequence similarity
                    alignments = pairwise2.align.globalxx(seqInputDict[parentName], seqInputDict[childName])
                    distanceCalculation = sum(1 for a, b in zip(alignments[0][0], alignments[0][1]) if a != b)
                    try:
                        if 100 - (distanceCalculation/ max(len(seqInputDict[parentName]), len(seqInputDict[childName])) * 100) <= SIMILARITY:
                            continue
                    except TypeError:
                        print(f'FATAL ERROR: "-s", "--similarity" parameter not provided, aborting analysis...\n')
                        exit()
                    if childName not in childParentComboDict and parentName not in childParentComboDict:
                        childParentComboDict[childName] = parentName
                        combinedDict[parentName].append(childName)
                        # now you can add child numbers to parent
                        for item in newParentDict:
                            newValue = int(newParentDict[item]) + int(freqInputDict[childName][item])
                            newParentDict[item] = newValue
                    elif childName in childParentComboDict and parentName not in childParentComboDict:
                        #print(f'{childName} already identified as child of {childParentComboDict[childName]}, but now also as child of {parentName}, while {parentName} is not identified as child of {childParentComboDict[childName]}')
                        # childName should've already been added to childParentComboDict[childName] at this stage.
                        # so nothing should happen, except keep a log of conflicts for future?
                        conflictDict[childName].append(childParentComboDict[childName])
                        conflictDict[childName].append(parentName)
                    elif childName not in childParentComboDict and parentName in childParentComboDict:
                        #print(f'{childName} identified as child of {parentName}, which in turn is a child of {childParentComboDict[parentName]}, though {childName} not identified as child of {childParentComboDict[parentName]}')
                        # here we should add childName to childParentComboDict[parentName], dependent on what is chosen to do with grandchildren
                        combinedDict[childParentComboDict[parentName]].append(childName)
                        childParentComboDict[childName] = childParentComboDict[parentName]
                        # now you can add child numbers to grandparent
                        for item in newlyUpdatedCountDict[childParentComboDict[parentName]]:
                            newValueGrandParent = int(newlyUpdatedCountDict[childParentComboDict[parentName]][item]) + int(freqInputDict[childName][item])
                            newlyUpdatedCountDict[childParentComboDict[parentName]][item] = newValueGrandParent
                    elif childName in childParentComboDict and parentName in childParentComboDict:
                        if childParentComboDict[childName] != childParentComboDict[parentName]:
                            print(f'both {childName} and {parentName} identified as children of different parents, i.e., {childParentComboDict[childName]} and {childParentComboDict[parentName]}, respectively')
                            # nothing should happen here, as childName is already added to childParentComboDict[childName], though not sure how this combo can happen, needs investigating
                except KeyError:
                    continue
            # if parentName not in childParentComboDict, add parent info to new Dict
            if parentName not in childParentComboDict:
                newlyUpdatedCountDict[parentName] = newParentDict

## write updated frequency table to output
    count = 0
    with open(FREQOUTPUT, 'w') as outfile:
        for item in newlyUpdatedCountDict:
            count += 1
            if count == 1:
                title = "\t".join(newlyUpdatedCountDict[item].keys())
                outfile.write(f'ID\t{title}\n')
            test = "\t".join(str(value) for value in newlyUpdatedCountDict[item].values())
            outfile.write(f'{item}\t{test}\n')

## write updated sequence file to output
    with open(SEQOUTPUT, 'w') as seqoutfile:
        for item in newlyUpdatedCountDict:
            seqoutfile.write(f'>{item}\n{seqInputDict[item]}\n')

## write updated taxonomy file to output
# should we add support to add NA for missing BLASTS?
    with open(TAXOUTPUT, 'w') as taxoutfile:
        for item in newlyUpdatedCountDict:
            try:
                taxoutfile.write(f'{taxTotalDict[item]}\n')
            except KeyError:
                continue

## write log
    print(f'\nSUMMARY STATISTICS:\nNumber of sequences analysed: {len(seqInputDict)}\nSequences identified as artifacts: {len(childParentComboDict)} ({float("{:.2f}".format(len(childParentComboDict) / len(seqInputDict) * 100))}%)\n\nDETAILED LOG:')
    for item in combinedDict:
        print(f'{item} identified as parent sequence of: {" + ".join(combinedDict[item])}')
    print()

############
# ARGPARSE #
############
def main():
    parser = argparse.ArgumentParser(description = 'identify and remove artefact sequences from metabarcoding data')
    parser.add_argument('--version', action = 'version', version = __version__)
    subparser = parser.add_subparsers()

    mrcaCalculatorParser = subparser.add_parser('mrcaCalculator', description = 'calculate the most recent common ancestor from BLAST')
    mrcaCalculatorParser.set_defaults(func = mrcaCalculator)
    
    mrcaMergerParser = subparser.add_parser('mrcaMerger', description = 'merge sequences based on the most recent common ancestor ID')
    mrcaMergerParser.set_defaults(func = mrcaMerger)

    occurMergerParser = subparser.add_parser('occurMerger', description = 'merge sequences based on co-occurrence patterns')
    occurMergerParser.set_defaults(func = occurMerger)

    tombRaiderParser = subparser.add_parser('tombRaider', description = 'merge sequences based on taxon-dependent co-occurrence patterns')
    tombRaiderParser.set_defaults(func = tombRaider)
    tombRaiderParser.add_argument('--frequency-input', help = 'frequency table input file name', dest = 'freqInput', type = str)
    tombRaiderParser.add_argument('--sequence-input', help = 'sequence input file name', dest = 'seqInput', type = str)
    tombRaiderParser.add_argument('--taxonomy-input', help = 'taxonomy input file name', dest = 'taxInput', type = str)
    tombRaiderParser.add_argument('--frequency-output', help = 'frequency table output file name', dest = 'freqOutput', type = str)
    tombRaiderParser.add_argument('--sequence-output', help = 'sequence output file name', dest = 'seqOutput', type = str)
    tombRaiderParser.add_argument('--taxonomy-output', help = 'taxonomy output file name', dest = 'taxOutput', type = str)
    tombRaiderParser.add_argument('--abundance', help = 'abundance threshold to consider true detection', dest = 'abund', type = int)
    tombRaiderParser.add_argument('--similarity', help = 'similarity threshold needed between child and parent', dest = 'similarity', type = int)

    args = parser.parse_args()
    args.func(args)

if __name__ == '__main__':
    main()
